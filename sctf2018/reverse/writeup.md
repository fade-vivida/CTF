# Reverse #
# Babymips #
## 1.题目分析 ##
一道简单的mips逆向题目，可以采用两种方法进行解题  
1.直接IDA逆向mips汇编指令  
2.使用RetDec+IDA  
在本例题中，使用RetDec+IDA的方式进行解题（乘此机会学习RetDec）
## 2.程序逻辑分析 ##
使用RetDec可以很方便的对程序进行反编译，从类C源码中分析程序流程。  
### 2.1 input进行预处理 ###
![step1](https://raw.githubusercontent.com/fade-vivida/CTF/master/sctf2018/reverse/picture/babymips1.JPG)  
ps：这反编译看起来真心蛋疼！！！  

	大体意思为:
    input[i] = input[i] ^ (((i+1) << 24) << 24)
### 2.2 对程序段进行动态解密 ###

![step2](https://raw.githubusercontent.com/fade-vivida/CTF/master/sctf2018/reverse/picture/babymips3.JPG)  
如图所示，程序接下来调用sub\_400A90函数对0x400b3c地址处的数据进行动态解密。  

0x400b3c处数据如下图所示：  
![data](https://raw.githubusercontent.com/fade-vivida/CTF/master/sctf2018/reverse/picture/babymips4.JPG)  

sub\_400A90函数如下图所示：    
![](https://raw.githubusercontent.com/fade-vivida/CTF/master/sctf2018/reverse/picture/babymips2.JPG)  
其中反编译结果有错误，真正解密源代码如下所示： 
 
    for j in range(len(encrypt_code)):
		tmp2 = 0
		for i in range(8):
			tmp0 = encrypt_code[j] >> i
			tmp1 = tmp0 & 1
			tmp1 = tmp1 << (7-i)
			#tmp1 = tmp1 << 24
			#tmp1 = tmp1 >> 24
			tmp2 = (tmp1 | tmp2) & 0xff
		decrypt_code.append(chr(tmp2))
### 2.3 分析解密后的memcmp函数 ###
首先对input[i]异或0x30,然后从第5个字符开始循环异或一个固定字符串。最终将计算后的值与一个固定字符串做比较。
## 3.最终解密脚本 ##
    import os
    
    encrypt_code = [
      0x03, 0xFF, 0xBD, 0xE4, 0x3C, 0x00, 0xFD, 0xF5, 
      0x1C, 0x00, 0x7D, 0xF5, 0xA4, 0x0F, 0x05, 0xC0, 0x42, 0x00, 
      0x38, 0x3C, 0x0E, 0x05, 0x39, 0xE4, 0x08, 0x00, 0x3D, 0xF5, 
      0x38, 0x00, 0x23, 0xF5, 0x18, 0x00, 0xA3, 0xF5, 0x12, 0x00, 
      0x63, 0xF5, 0x01, 0x01, 0x41, 0xF1, 0x00, 0x00, 0x42, 0x31, 
      0x2C, 0x00, 0x43, 0xF5, 0x38, 0x00, 0x43, 0xF1, 0xEA, 0x00, 
      0x02, 0x08, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x43, 0xF1, 
      0x2A, 0x00, 0x02, 0x08, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 
      0xC3, 0xF1, 0x64, 0x00, 0x40, 0x24, 0x20, 0x00, 0x46, 0x08, 
      0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x40, 0x24, 0x72, 0x00, 
      0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x40, 0x24, 
      0x24, 0x00, 0x43, 0xF5, 0x24, 0x00, 0x43, 0xF1, 0xA4, 0x00, 
      0x42, 0x14, 0x88, 0x00, 0x02, 0x08, 0x00, 0x00, 0x00, 0x00, 
      0x24, 0x00, 0x43, 0xF1, 0x38, 0x00, 0xC3, 0xF1, 0x84, 0x08, 
      0x46, 0x00, 0x24, 0x00, 0xC3, 0xF1, 0x38, 0x00, 0x23, 0xF1, 
      0x84, 0x18, 0xC1, 0x00, 0x00, 0x00, 0xC6, 0x01, 0x0C, 0x00, 
      0xC6, 0x1C, 0x00, 0x78, 0xC0, 0x00, 0xC0, 0x78, 0xC0, 0x00, 
      0x00, 0x00, 0xC2, 0x05, 0x24, 0x00, 0x43, 0xF1, 0x80, 0x00, 
      0x42, 0x24, 0x24, 0x00, 0x43, 0xF5, 0xB7, 0xFF, 0x00, 0x08, 
      0x00, 0x00, 0x00, 0x00, 0x2E, 0x66, 0x40, 0x3C, 0xCE, 0xC6, 
      0x42, 0x2C, 0x34, 0x00, 0x43, 0xF5, 0x0C, 0x00, 0x03, 0xC5, 
      0xA0, 0x00, 0x40, 0x24, 0x14, 0x00, 0x43, 0xF5, 0x14, 0x00, 
      0x43, 0xF1, 0xA4, 0x00, 0x42, 0x14, 0xF8, 0x00, 0x02, 0x08, 
      0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x43, 0xF1, 0x38, 0x00, 
      0xC3, 0xF1, 0x84, 0x18, 0x46, 0x00, 0x14, 0x00, 0x43, 0xF1, 
      0x38, 0x00, 0x23, 0xF1, 0x84, 0x08, 0x41, 0x00, 0x00, 0x00, 
      0x22, 0x01, 0x14, 0x00, 0x43, 0xF1, 0xDF, 0xFF, 0xA2, 0x24, 
      0x00, 0x01, 0x40, 0x3C, 0xC0, 0x00, 0x42, 0x2C, 0x24, 0x08, 
      0x45, 0x00, 0xA0, 0x00, 0x82, 0x20, 0x00, 0x00, 0x00, 0x00, 
      0xFF, 0xFF, 0x42, 0x24, 0x3F, 0xFF, 0xA0, 0x24, 0xA4, 0x08, 
      0xA2, 0x00, 0x80, 0x00, 0x42, 0x24, 0x1C, 0x00, 0xA3, 0xE4, 
      0x84, 0x08, 0x45, 0x00, 0x2F, 0xFF, 0x42, 0x01, 0x64, 0x08, 
      0x41, 0x00, 0x00, 0x68, 0x40, 0x00, 0xC0, 0x68, 0x40, 0x00, 
      0x00, 0x00, 0x46, 0x05, 0x14, 0x00, 0x43, 0xF1, 0x80, 0x00, 
      0x42, 0x24, 0x14, 0x00, 0x43, 0xF5, 0xFB, 0xFF, 0x00, 0x08, 
      0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x60, 0x24, 0x38, 0x00, 
      0xA3, 0xF1, 0x82, 0x00, 0x40, 0x3C, 0x1C, 0x04, 0x22, 0x24, 
      0x2E, 0x01, 0x41, 0xF1, 0xA4, 0x13, 0x02, 0x00, 0x90, 0x1F, 
      0x04, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x3B, 0xF1, 
      0x20, 0x00, 0x02, 0x28, 0x00, 0x00, 0x00, 0x00, 0xA4, 0x08, 
      0x00, 0x00, 0x40, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 
      0x80, 0x00, 0x40, 0x24, 0x01, 0x01, 0xC1, 0xF1, 0x2C, 0x00, 
      0x23, 0xF1, 0x00, 0x00, 0xC6, 0x31, 0xA0, 0x00, 0xC1, 0x08, 
      0x00, 0x00, 0x00, 0x00, 0x36, 0x01, 0x41, 0xF1, 0xA4, 0x13, 
      0x02, 0x00, 0x90, 0x1F, 0x04, 0xC0, 0x00, 0x00, 0x00, 0x00, 
      0xA4, 0x17, 0x03, 0xC0, 0x3C, 0x00, 0xFD, 0xF1, 0x1C, 0x00, 
      0x7D, 0xF1, 0x02, 0x00, 0xBD, 0xE4, 0x10, 0x00, 0x07, 0xC0, 
      0x00, 0x00, 0x00, 0x00]
    
    data_xor = [
    	0x73,0x63,0x74,0x66]
    
    data_check =[
    	0x72, 0x61, 0x77, 0x62, 0x7E, 0x07, 0x35, 0x2E, 0x26, 0x24, 
      	0x31, 0x38, 0x28, 0x12, 0x35, 0x07, 0x18, 0x22, 0x2F, 0x0F, 
      	0x26, 0x34, 0x71, 0x25, 0x10, 0x20, 0x27, 0x37, 0x24, 0x32, 
      	0x23, 0x0B, 0x18, 0x0E, 0x1F, 0x0F, 0x52, 0x5B]
    
    step1 = 1
    if step1 == 0:
    	print encrypt_code
    	decrypt_code = []
    	print hex(len(encrypt_code))
    	for j in range(len(encrypt_code)):
    		tmp2 = 0
    		for i in range(8):
    			tmp0 = encrypt_code[j] >> i
    			tmp1 = tmp0 & 1
    			tmp1 = tmp1 << (7-i)
    			#tmp1 = tmp1 << 24
    			#tmp1 = tmp1 >> 24
    			tmp2 = (tmp1 | tmp2) & 0xff
    		decrypt_code.append(chr(tmp2))
    		print hex(tmp2),
    	print decrypt_code
    
    	fp = open('a.txt','wb')
    	fp.write(''.join(decrypt_code))
    	fp.close()
    
    step2 = 0
    result = []
    if step2 == 0:
    	for i in range(5,0x25):
    		for j in range(0x100):
    			tmp = (((i+1) << 24) >> 24) ^ j
    			tmp = (tmp << 24) >> 24
    			tmp = tmp ^ 0x30
    			tmp = (tmp << 24) >> 24
    			tmp = tmp ^ data_xor[(i-5)%4]
    			tmp = (tmp << 24) >> 24
    			if tmp == data_check[i]:
    				print j,chr(j),
    				result.append(chr(j))
    		print '\n'
    print 'sctf{' + ''.join(result) + '}'

